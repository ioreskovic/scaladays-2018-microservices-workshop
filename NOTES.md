# ScalaDays 2018 Notes
## Domain Driven Design and Microservices
### Day 1
Events first. What happens in our case?  
What commands trigger those events?  
Aggregates emerge by themselves.  
Look for dynamic properties of our system.  
Aggregate (persistent entity) validates command. It takes command and produces either an error or event(s).  
Akka (Erlang?) blog: Let it crash!!!  
No formal language for Event Storming.

#### Links
  * http://www.russmiles.com/essais/going-events-first-for-microservices-with-event-storming-and-ddd
  * http://ziobrando.blogspot.de/2013/11/introducing-event-storming.html
  * https://leanpub.com/introducing_eventstorming
  * https://www.lagomframework.com/
  * https://blog.redelastic.com/corporate-arts-crafts-modelling-reactive-systems-with-event-storming-73c6236f5dd7
  
Event is past fact, which has happened (usually past perfect tense)  
Aggregates should define transaction boundary, where actions happen atomically.  
  
#### Terminology / Legend
  * Event
    + Business event
    + Past tense, irrefutable fact that happened
  * Definition
    + Defines ubiquitous language
  * Note
    + Invariants
  * Marker
    + Revisit later, important
  * Policy
    + IFTTT
    + Usually generated by the system
    + Usually produces other events
  * Command
    + Imperative
    + Requested action, which will result in state change and possible more events
  * Actor
    + Command issuer
  * View
    + Data exposed
  
